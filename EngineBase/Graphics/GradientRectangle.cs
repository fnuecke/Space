using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;

namespace Engine.Graphics
{
    /// <summary>
    /// Utility class for rendering filled gradient rectangles, interpolating
    /// between multiple colors.
    /// </summary>
    public sealed class GradientRectangle : AbstractShape
    {
        #region Fields

        /// <summary>
        /// The colors to use when blending.
        /// </summary>
        private readonly Vector4[] _colors = new Vector4[3];

        /// <summary>
        /// The points on the interval from and to which to interpolate.
        /// </summary>
        private readonly float[] _points = new float[3];

        /// <summary>
        /// The actual number of points currently in use.
        /// </summary>
        private int _numPoints;

        #endregion

        #region Constructor

        /// <summary>
        /// Creates a new gradient rectangle renderer for the given game.
        /// </summary>
        /// <param name="content">The content manager to use for loading assets.</param>
        /// <param name="graphics">The graphics device to render to.</param>
        public GradientRectangle(ContentManager content, GraphicsDevice graphics)
            : base(content, graphics, "Shaders/GradientRectangle")
        {
            // Set defaults.
            SetGradients(new[] { Color.Black, Color.White }, new[] { 0f, 1f });
        }

        #endregion

        #region Accessors

        /// <summary>
        /// Sets the gradient points with their colors to use for interpolating
        /// the color over the size of this rectangle.
        /// 
        /// <para>
        /// A minimum of two points and two colors is required, and the number
        /// of colors has to be same as the number of points. The colors will
        /// then be interpolated between the relative positions of the points.
        /// </para>
        /// </summary>
        /// <param name="colors">The colors between which to interpolate.</param>
        /// <param name="points">The points between which to interpolate.</param>
        public void SetGradients(Color[] colors, float[] points)
        {
            if (colors == null || points == null)
            {
                throw new ArgumentNullException(colors == null ? "colors" : "points");
            }
            if (colors.Length != points.Length)
            {
                throw new ArgumentException("Number of colors not equal to the number of points.", "colors");
            }
            if (colors.Length > _colors.Length)
            {
                throw new ArgumentException("Maximum number of points exceeded.", "colors");
            }
            var lowest = points[0];
            for (var i = 1; i < points.Length; i++)
            {
                if (points[i] >= lowest)
                {
                    lowest = points[i];
                }
                else
                {
                    throw new ArgumentException("Points are not ascending in order.", "points");
                }
            }

            _numPoints = colors.Length;

            for (var i = 0; i < colors.Length; i++)
            {
                _colors[i] = colors[i].ToVector4();
            }

            points.CopyTo(_points, 0);
        }

        /// <summary>
        /// Sets the gradient points with the colors to use for interpolating
        /// the color over the size of the rectangle.
        /// 
        /// <para>
        /// A minimum of two colors is required. The points will be
        /// automatically generated by linear interpolation.
        /// </para>
        /// </summary>
        /// <param name="colors">The colors between which to interpolate.</param>
        public void SetGradients(Color[] colors)
        {
            if (colors == null)
            {
                throw new ArgumentNullException("colors");
            }
            if (colors.Length > _colors.Length)
            {
                throw new ArgumentException("Maximum number of points exceeded.", "colors");
            }

            _numPoints = colors.Length;

            for (var i = 0; i < colors.Length; i++)
            {
                _colors[i] = colors[i].ToVector4();
                _points[i] = MathHelper.Lerp(0f, 1f, i / (float)(_numPoints - 1));
            }
        }

        #endregion

        #region Draw

        /// <summary>
        /// Adjusts effect parameters prior to the draw call.
        /// </summary>
        protected override void AdjustParameters()
        {
            base.AdjustParameters();

            var colors = Effect.Parameters["Colors"];
            if (colors != null)
            {
                colors.SetValue(_colors);
            }
            var points = Effect.Parameters["Points"];
            if (points != null)
            {
                points.SetValue(_points);
            }
            var numValues = Effect.Parameters["NumValues"];
            if (numValues != null)
            {
                numValues.SetValue(_numPoints);
            }

            var gradient = Effect.Parameters["Gradient"];
            if (gradient != null)
            {
                Vector2 g;
                g.X = 2f / Width;
                g.Y = 2f / Height;
                gradient.SetValue(g);
            }
        }

        #endregion
    }
}
