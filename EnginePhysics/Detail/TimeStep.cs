using Microsoft.Xna.Framework;

#if FARMATH
using LocalPoint = Microsoft.Xna.Framework.Vector2;
using WorldPoint = Engine.FarMath.FarPosition;
using WorldBounds = Engine.FarMath.FarRectangle;
#else
using LocalPoint = Microsoft.Xna.Framework.Vector2;
using WorldPoint = Microsoft.Xna.Framework.Vector2;
using WorldBounds = Engine.Math.RectangleF;
#endif

namespace Engine.Physics.Detail
{
    /// <summary>
    /// Used by solver, generated in step and substeps.
    /// </summary>
    internal struct TimeStep
    {
        /// <summary>
        /// The time step.
        /// </summary>
        public float DeltaT;

        /// <summary>
        /// Whether the solver is warm starting or not.
        /// </summary>
        public bool IsWarmStarting;
    }

    /// <summary>
    /// Used by contact solver, generated by island.
    /// </summary>
    internal struct Position
    {
        /// <summary>
        /// The position in world coordinates.
        /// </summary>
        public WorldPoint Point;

        /// <summary>
        /// The world angle.
        /// </summary>
        public float Angle;
    }

    /// <summary>
    /// Used by contact solver, generated by island.
    /// </summary>
    internal struct Velocity
    {
        /// <summary>
        /// The linear velocity component.
        /// </summary>
        public Vector2 LinearVelocity;

        /// <summary>
        /// The angular velocity component.
        /// </summary>
        public float AngularVelocity;
    }
}
