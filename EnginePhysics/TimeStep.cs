using System.Diagnostics;
using Microsoft.Xna.Framework;

#if FARMATH
using WorldPoint = Engine.FarMath.FarPosition;
#else
using WorldPoint = Microsoft.Xna.Framework.Vector2;
#endif

namespace Engine.Physics
{
    /// <summary>Used by solver, generated in step and substeps.</summary>
    internal struct TimeStep
    {
        /// <summary>The time step and its inverse.</summary>
        public float DeltaT, InverseDeltaT;
    }

    /// <summary>Used by contact solver, generated by island.</summary>
    internal struct Position
    {
        /// <summary>The position in world coordinates.</summary>
        public WorldPoint Point;

        /// <summary>The world angle.</summary>
        public float Angle;
    }

    /// <summary>Used by contact solver, generated by island.</summary>
    internal struct Velocity
    {
        /// <summary>The linear velocity component.</summary>
        public Vector2 LinearVelocity;

        /// <summary>The angular velocity component.</summary>
        public float AngularVelocity;
    }

    /// <summary>Used to collect profiling data.</summary>
    public sealed class Profile
    {
        /// <summary>Time taken for complete update.</summary>
        public double Step
        {
            get { return _step; }
        }

        /// <summary>Time taken for finding collisions.</summary>
        public double Collide
        {
            get { return _collide; }
        }

        /// <summary>Time taken by normal solver.</summary>
        public double Solve
        {
            get { return _solve; }
        }

        /// <summary>Time taken by accumulative initialization of solver (for all islands).</summary>
        public double SolveInit
        {
            get { return _solveInit; }
        }

        /// <summary>Time taken by accumulative velocity solving (for all islands).</summary>
        public double SolveVelocity
        {
            get { return _solveVelocity; }
        }

        /// <summary>Time taken by accumulative position solving (for all islands).</summary>
        public double SolvePosition
        {
            get { return _solvePosition; }
        }

        /// <summary>Time taken by broadphase update (finding new contacts).</summary>
        public double Broadphase
        {
            get { return _broadphase; }
        }

        /// <summary>Time taken by TOI solver.</summary>
        public double SolveTOI
        {
            get { return _solveTOI; }
        }

        /// <summary>Stop watch used to measure complete update.</summary>
        private readonly Stopwatch _updateWatch = new Stopwatch();

        /// <summary>Stop watch used to measure solvers and broadphase updates.</summary>
        private readonly Stopwatch _solverWatch = new Stopwatch();

        /// <summary>Stop watch used to measure solver sub-steps (init, velocity and position).</summary>
        private readonly Stopwatch _islandWatch = new Stopwatch();

        /// <summary>Time taken for complete update.</summary>
        private double _step;

        /// <summary>Time taken for finding collisions.</summary>
        private double _collide;

        /// <summary>Time taken by normal solver.</summary>
        private double _solve;

        /// <summary>Time taken by accumulative initialization of solver (for all islands).</summary>
        private double _solveInit;

        /// <summary>Time taken by accumulative velocity solving (for all islands).</summary>
        private double _solveVelocity;

        /// <summary>Time taken by accumulative position solving (for all islands).</summary>
        private double _solvePosition;

        /// <summary>Time taken by broadphase update (finding new contacts).</summary>
        private double _broadphase;

        /// <summary>Time taken by TOI solver.</summary>
        private double _solveTOI;

        [Conditional("PROFILE")]
        internal void BeginStep()
        {
            _updateWatch.Restart();
        }

        private static readonly double TicksToMilliseconds = 1000.0 / Stopwatch.Frequency;

        [Conditional("PROFILE")]
        internal void EndStep()
        {
            _updateWatch.Stop();
            _step = _updateWatch.ElapsedTicks;

            _step *= TicksToMilliseconds;
            _collide *= TicksToMilliseconds;
            _solve *= TicksToMilliseconds;
            _solveInit *= TicksToMilliseconds;
            _solveVelocity *= TicksToMilliseconds;
            _solvePosition *= TicksToMilliseconds;
            _broadphase *= TicksToMilliseconds;
            _solveTOI *= TicksToMilliseconds;
        }

        [Conditional("PROFILE")]
        internal void BeginCollide()
        {
            _solverWatch.Restart();
        }

        [Conditional("PROFILE")]
        internal void EndCollide()
        {
            _solverWatch.Stop();
            _collide = _solverWatch.ElapsedTicks;
        }

        [Conditional("PROFILE")]
        internal void BeginSolve()
        {
            _solverWatch.Restart();

            // Reset for ensuing accumulation. Arrr.
            _solveInit = 0;
            _solveVelocity = 0;
            _solvePosition = 0;
        }

        [Conditional("PROFILE")]
        internal void EndSolve()
        {
            _solverWatch.Stop();
            _solve = _solverWatch.ElapsedTicks;
        }

        [Conditional("PROFILE")]
        internal void BeginSolveInit()
        {
            _islandWatch.Restart();
        }

        [Conditional("PROFILE")]
        internal void EndSolveInit()
        {
            _islandWatch.Stop();
            _solveInit += _islandWatch.ElapsedTicks;
        }

        [Conditional("PROFILE")]
        internal void BeginSolveVelocity()
        {
            _islandWatch.Restart();
        }

        [Conditional("PROFILE")]
        internal void EndSolveVelocity()
        {
            _islandWatch.Stop();
            _solveVelocity += _islandWatch.ElapsedTicks;
        }

        [Conditional("PROFILE")]
        internal void BeginSolvePosition()
        {
            _islandWatch.Restart();
        }

        [Conditional("PROFILE")]
        internal void EndSolvePosition()
        {
            _islandWatch.Stop();
            _solvePosition += _islandWatch.ElapsedTicks;
        }

        [Conditional("PROFILE")]
        internal void BeginSolveTOI()
        {
            _solverWatch.Restart();
        }

        [Conditional("PROFILE")]
        internal void EndSolveTOI()
        {
            _solverWatch.Stop();
            _solveTOI = _solverWatch.ElapsedTicks;
        }

        [Conditional("PROFILE")]
        internal void BeginBroadphase()
        {
            _solverWatch.Restart();
        }

        [Conditional("PROFILE")]
        internal void EndBroadphase()
        {
            _solverWatch.Stop();
            _broadphase = _solverWatch.ElapsedTicks;
        }
    }
}